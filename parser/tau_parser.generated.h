// This file is generated by 
//       https://github.com/IDNI/parser/tools/parser_gen
// from the grammar in file: parser/tau.tgf
// The content of the file parser/tau.tgf is:
// @use_char_class eof, space, digit, xdigit, alpha, alnum, punct, printable.
// 
// # whitespace and comments
// eol            => '\n' | '\r' | eof.
// ws_comment     => '#' eol | '#' printable+ eol.
// ws_required    => space ws | ws_comment ws.
// ws             => ws_required | null.
// 
// # characters
// hex_escape     => "\\x" xdigit xdigit.
// unicode_escape => "\\u" xdigit xdigit xdigit xdigit.
// char_escape_encode => hex_escape | unicode_escape.
// 
// # defining char/string/qstring as all chars but its wrapping character
// # enables using TAB and new lines in char(')/string(")/bqstring(`)
// # sequences
// esc            => "\\\\".
// q_char         => '\''.
// q_str          => '"'.
// q_bqstr        => '`'.
// char_punct     => punct & ~q_char & ~q_str & ~q_bqstr
// 		& ~(esc q_char) & ~(esc q_str) & ~(esc q_bqstr).
// char0          => alnum | space | char_escape_encode | char_punct.
// char_          => char0 | esc q_char |     q_str |     q_bqstr.
// string_char    => char0 |     q_char | esc q_str |     q_bqstr.
// bqstring_char  => char0 |     q_char |     q_str | esc q_bqstr.
// chars          => alpha (alnum)*.
// 
// # elements
// sym            => chars.
// ignore           => "??".
// var           => '?' chars.
// 
// # term
// term           => negative_term | positive_term.
// negative_term  => '~' ws positive_term.
// positive_term  => relname args | relname.
// args           => ws '(' ws elems ws ')' | ws '(' ws ')'.
// elems          => elem | elem ws_required elems_rest | relname args
// 		| relname args ws elems_rest.
// elems_rest     => elem | elem args | elem ws_required elems_rest | args.
// elem           => sym | var | ignore.
// relname        => sym.
// 
// char_class    => "eof" | "alnum" | "alpha" | "blank" | "cntrl" | "digit"
// 		| "graph" | "lower" | "printable" | "punct" | "space"
// 		| "upper" | "xdigit".
// 
// # FO formula statement
// form           => form1  (ws causal_op ws form1)*.
// form1          => matrix (ws junct_op ws matrix)*.
// causal_op      => implies | coimplies.
// junct_op       => and_ | or_.
// and_           => "&&".
// or_            => "||".
// implies        => "->".
// coimplies      => "<->".
// 
// matrix         => neg_matrix | matrix_block | prefix_decl | positive_term.
// neg_matrix     => '~' matrix.
// matrix_block   => '{' ws form ws '}'.
// prefix_decl    => prefix ws prefix_arg ws form.
// prefix         => "forall" | "exists" | "unique".
// prefix_arg     => var | ivar.
// 
// rule		   => matrix ws ":-" ws matrix ws '.'.
// rules          => (ws rule)*.
// main 		   => matrix ws '.'.
// program        => ws rules ws main ws.
// start          => program.
// 

#include <string.h>
#include "parser.h"
struct tau_parser {
	tau_parser() :
		nts(load_nonterminals()), cc(load_cc()),
		g(nts, load_prods(), nt(70), cc), p(g) { }
	std::unique_ptr<typename idni::parser<char>::pforest> parse(
		const char* data, size_t size = 0,
		char eof = std::char_traits<char>::eof())
			{ return p.parse(data, size, eof); }
	std::unique_ptr<typename idni::parser<char>::pforest> parse(
		std::basic_istream<char>& is,
		size_t size = 0,
		char eof = std::char_traits<char>::eof())
			{ return p.parse(is, size, eof); }
	bool found() { return p.found(); }
	typename idni::parser<char>::perror_t get_error()
		{ return p.get_error(); }
   enum struct nonterminal : size_t {

			empty_string, eof, space, digit, xdigit, alpha, alnum, punct, printable, eol, 
			ws_comment, _Rws_comment_0, ws_required, ws, hex_escape, unicode_escape, char_escape_encode, esc, q_char, q_str, 
			q_bqstr, char_punct, _Rchar_punct_1, _Rchar_punct_2, _Rchar_punct_3, char0, char_, string_char, bqstring_char, chars, 
			_Rchars_4, _Rchars_5, sym, ignore, var, term, negative_term, positive_term, relname, args, 
			elems, elem, elems_rest, char_class, form, form1, causal_op, _Rform_6, _Rform_7, matrix, 
			junct_op, _Rform1_8, _Rform1_9, implies, coimplies, and_, or_, neg_matrix, matrix_block, prefix_decl, 
			prefix, prefix_arg, ivar, rule, rules, _Rrules_10, _Rrules_11, main, program, start, 
			tau_parser, 
   };
private:
	std::vector<char> ts{
		'\0', '\n', '\r', '#', '\\', 'x', 'u', '\'', '"', 
		'`', '?', '~', '(', ')', 'a', 'l', 'n', 'm', 'p', 
		'h', 'b', 'k', 'c', 't', 'r', 'd', 'i', 'g', 'e', 
		'o', 'f', 'w', 's', '&', '|', '-', '>', '<', '{', 
		'}', 'q', ':', '.', 
	};
	idni::nonterminals<char> nts{};
	idni::char_class_fns<char> cc;
	idni::grammar<char> g;
	idni::parser<char> p;
	idni::prods<char> t(size_t tid) {
		return idni::prods<char>(ts[tid]);
	}
	idni::prods<char> nt(size_t ntid) {
		return idni::prods<char>(idni::lit<char>(ntid, &nts));
	}
	idni::nonterminals<char> load_nonterminals() const {
		idni::nonterminals<char> nts{};
		for (const auto& nt : {
			"", "eof", "space", "digit", "xdigit", "alpha", "alnum", "punct", "printable", "eol", 
			"ws_comment", "_Rws_comment_0", "ws_required", "ws", "hex_escape", "unicode_escape", "char_escape_encode", "esc", "q_char", "q_str", 
			"q_bqstr", "char_punct", "_Rchar_punct_1", "_Rchar_punct_2", "_Rchar_punct_3", "char0", "char_", "string_char", "bqstring_char", "chars", 
			"_Rchars_4", "_Rchars_5", "sym", "ignore", "var", "term", "negative_term", "positive_term", "relname", "args", 
			"elems", "elem", "elems_rest", "char_class", "form", "form1", "causal_op", "_Rform_6", "_Rform_7", "matrix", 
			"junct_op", "_Rform1_8", "_Rform1_9", "implies", "coimplies", "and_", "or_", "neg_matrix", "matrix_block", "prefix_decl", 
			"prefix", "prefix_arg", "ivar", "rule", "rules", "_Rrules_10", "_Rrules_11", "main", "program", "start", 
			"tau_parser", 
		}) nts.get(nt);
		return nts;
	}
	idni::char_class_fns<char> load_cc() {
		return idni::predefined_char_classes<char>({
			"eof",
			"space",
			"digit",
			"xdigit",
			"alpha",
			"alnum",
			"punct",
			"printable",
		}, nts);
	}
	idni::prods<char> load_prods() {
		idni::prods<char> q, nul(idni::lit<char>{});
		q(nt(9), (nt(1)));
		q(nt(9), (t(1)));
		q(nt(9), (t(2)));
		q(nt(11), (t(3)+nt(8)));
		q(nt(11), (t(3)+nt(8)+nt(11)));
		q(nt(10), (nt(11)+nt(9)));
		q(nt(10), (t(3)+nt(9)));
		q(nt(12), (nt(2)+nt(13)));
		q(nt(12), (nt(10)+nt(13)));
		q(nt(13), (nt(12)));
		q(nt(13), (nul));
		q(nt(14), (t(4)+t(4)+t(5)+nt(4)+nt(4)));
		q(nt(15), (t(4)+t(4)+t(6)+nt(4)+nt(4)+nt(4)+nt(4)));
		q(nt(16), (nt(14)));
		q(nt(16), (nt(15)));
		q(nt(17), (t(4)+t(4)+t(4)+t(4)));
		q(nt(18), (t(7)));
		q(nt(19), (t(8)));
		q(nt(20), (t(9)));
		q(nt(22), (nt(17)+nt(18)));
		q(nt(23), (nt(17)+nt(19)));
		q(nt(24), (nt(17)+nt(20)));
		q(nt(21), (nt(7)) & (nt(18)) & (nt(19)) & (nt(20)) & (nt(22)) & (nt(23)) & (nt(24)));
		q(nt(25), (nt(2)));
		q(nt(25), (nt(6)));
		q(nt(25), (nt(16)));
		q(nt(25), (nt(21)));
		q(nt(26), (nt(17)+nt(18)));
		q(nt(26), (nt(19)));
		q(nt(26), (nt(20)));
		q(nt(26), (nt(25)));
		q(nt(27), (nt(17)+nt(19)));
		q(nt(27), (nt(18)));
		q(nt(27), (nt(20)));
		q(nt(27), (nt(25)));
		q(nt(28), (nt(17)+nt(20)));
		q(nt(28), (nt(18)));
		q(nt(28), (nt(19)));
		q(nt(28), (nt(25)));
		q(nt(30), (nt(6)));
		q(nt(31), (nt(30)+nt(31)));
		q(nt(31), (nul));
		q(nt(29), (nt(5)+nt(31)));
		q(nt(32), (nt(29)));
		q(nt(33), (t(10)+t(10)));
		q(nt(34), (t(10)+nt(29)));
		q(nt(35), (nt(36)));
		q(nt(35), (nt(37)));
		q(nt(36), (t(11)+nt(13)+nt(37)));
		q(nt(37), (nt(38)));
		q(nt(37), (nt(38)+nt(39)));
		q(nt(39), (nt(13)+t(12)+nt(13)+nt(40)+nt(13)+t(13)));
		q(nt(39), (nt(13)+t(12)+nt(13)+t(13)));
		q(nt(40), (nt(38)+nt(39)));
		q(nt(40), (nt(38)+nt(39)+nt(13)+nt(42)));
		q(nt(40), (nt(41)));
		q(nt(40), (nt(41)+nt(12)+nt(42)));
		q(nt(42), (nt(39)));
		q(nt(42), (nt(41)));
		q(nt(42), (nt(41)+nt(12)+nt(42)));
		q(nt(42), (nt(41)+nt(39)));
		q(nt(41), (nt(32)));
		q(nt(41), (nt(33)));
		q(nt(41), (nt(34)));
		q(nt(38), (nt(32)));
		q(nt(43), (t(14)+t(15)+t(16)+t(6)+t(17)));
		q(nt(43), (t(14)+t(15)+t(18)+t(19)+t(14)));
		q(nt(43), (t(20)+t(15)+t(14)+t(16)+t(21)));
		q(nt(43), (t(22)+t(16)+t(23)+t(24)+t(15)));
		q(nt(43), (t(25)+t(26)+t(27)+t(26)+t(23)));
		q(nt(43), (t(28)+t(29)+t(30)));
		q(nt(43), (t(27)+t(24)+t(14)+t(18)+t(19)));
		q(nt(43), (t(15)+t(29)+t(31)+t(28)+t(24)));
		q(nt(43), (t(18)+t(24)+t(26)+t(16)+t(23)+t(14)+t(20)+t(15)+t(28)));
		q(nt(43), (t(18)+t(6)+t(16)+t(22)+t(23)));
		q(nt(43), (t(32)+t(18)+t(14)+t(22)+t(28)));
		q(nt(43), (t(6)+t(18)+t(18)+t(28)+t(24)));
		q(nt(43), (t(5)+t(25)+t(26)+t(27)+t(26)+t(23)));
		q(nt(47), (nt(13)+nt(46)+nt(13)+nt(45)));
		q(nt(48), (nt(47)+nt(48)));
		q(nt(48), (nul));
		q(nt(44), (nt(45)+nt(48)));
		q(nt(51), (nt(13)+nt(50)+nt(13)+nt(49)));
		q(nt(52), (nt(51)+nt(52)));
		q(nt(52), (nul));
		q(nt(45), (nt(49)+nt(52)));
		q(nt(46), (nt(53)));
		q(nt(46), (nt(54)));
		q(nt(50), (nt(55)));
		q(nt(50), (nt(56)));
		q(nt(55), (t(33)+t(33)));
		q(nt(56), (t(34)+t(34)));
		q(nt(53), (t(35)+t(36)));
		q(nt(54), (t(37)+t(35)+t(36)));
		q(nt(49), (nt(37)));
		q(nt(49), (nt(57)));
		q(nt(49), (nt(58)));
		q(nt(49), (nt(59)));
		q(nt(57), (t(11)+nt(49)));
		q(nt(58), (t(38)+nt(13)+nt(44)+nt(13)+t(39)));
		q(nt(59), (nt(60)+nt(13)+nt(61)+nt(13)+nt(44)));
		q(nt(60), (t(28)+t(5)+t(26)+t(32)+t(23)+t(32)));
		q(nt(60), (t(30)+t(29)+t(24)+t(14)+t(15)+t(15)));
		q(nt(60), (t(6)+t(16)+t(26)+t(40)+t(6)+t(28)));
		q(nt(61), (nt(34)));
		q(nt(61), (nt(62)));
		q(nt(63), (nt(49)+nt(13)+t(41)+t(35)+nt(13)+nt(49)+nt(13)+t(42)));
		q(nt(65), (nt(13)+nt(63)));
		q(nt(66), (nt(65)+nt(66)));
		q(nt(66), (nul));
		q(nt(64), (nt(66)));
		q(nt(67), (nt(49)+nt(13)+t(42)));
		q(nt(68), (nt(13)+nt(64)+nt(13)+nt(67)+nt(13)));
		q(nt(69), (nt(68)));
		return q;
	}
};
