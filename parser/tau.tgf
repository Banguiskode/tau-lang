@use_char_class eof, space, digit, xdigit, alpha, alnum, punct, printable.

#
# as a rule of thumb, to ease navigation of the corresponding tree, the
# non-terminals shouldn't appear in * or + expressions. Otherwise,
# intermediate non terminals would be created and break the expected tree
# structure
#

# whitespace and comments
eol                    => '\n' | '\r' | eof.
ws_comment             => '#' (printable | '\t')* eol.
ws_required            => space ws | ws_comment ws.
ws                     => ws_required | null.

# characters
hex_escape             => "\\x" xdigit xdigit.
unicode_escape         => "\\u" xdigit xdigit xdigit xdigit.
char_escape_encode     => hex_escape | unicode_escape.

# defining char/string/qstring as all chars but its wrapping character
# enables using TAB and new lines in char(')/string(")/bqstring(`)
# sequences

# common stuff copy cut from tml grammar
esc                    => "\\\\".
q_char                 => '\''.
q_str                  => '"'.
q_bqstr                => '`'.
char_punct             => punct & ~q_char & ~q_str & ~q_bqstr
			& ~(esc q_char) & ~(esc q_str) & ~(esc q_bqstr).
char0                  => alnum | space | char_escape_encode | char_punct.
char_                  => char0 | esc q_char |     q_str |     q_bqstr.
string_char            => char0 |     q_char | esc q_str |     q_bqstr.
bqstring_char          => char0 |     q_char |     q_str | esc q_bqstr.
chars                  => alpha (alnum)*.
digits                 => digit+.

# common symbols
bf_def             	   => ":=". # for rewriting rules and bf rec. relations bf_def and rules
wff_def                => "::=". # for wff rec. relations bf_def and rules
tau_def                => ":::=". # for tau rules
dot                    => '.'.
open_parenthesis       => '('.
close_parenthesis      => ')'.
open_bracket           => '['.
close_bracket          => ']'.
open_brace             => '{'.
close_brace            => '}'.
minus                  => '-'.
colon                  => ':'.
semicolon              => ';'.
less                   => '<'.
comma                  => ','.

# elements
sym                    => chars.

# offsets
# TODO (HIGH) check programatically that no shift is use in a rec_relation defs
offsets                => open_bracket ws offset (ws comma ws offset)* ws close_bracket.
offset                 => num | capture | shift | (variable & ~io_var).
shift                  => (capture | (variable & ~io_var)) ws minus ws num.
num                    => digits.

# IDEA maybe use quantified_variable => (variable | capture) in quantifiers
# to cimplify the code.
variable               => var | io_var.
io_var                 => in | out.
in                     => in_var_name open_bracket offset close_bracket.
out                    => out_var_name open_bracket offset close_bracket.
bool_variable          => '?' chars.
capture                => capture_var.
capture_var            => '$' chars.
var                    => chars.
in_var_name            => "i_" chars.
out_var_name           => "o_" chars.

# tau
tau_rule               => tau_matcher ws tau_def ws tau_body ws dot ws.
tau_matcher            => tau.
tau_body               => tau | tau_collapse_positives_cb | tau_positives_upwards_cb.
tau_rec_relation	   => (tau & ~tau_and & ~tau_neg & ~tau_or & ~tau_wff & ~capture)
			ws tau_def ws tau ws dot ws.
tau_ref                => sym ws offsets ws tau_ref_args.
tau_ref_args           => open_parenthesis (ws (variable | capture))* ws close_parenthesis.


tau                    => tau_wff | tau_ref | tau_and | tau_or | tau_neg | capture.
tau_and                => open_parenthesis ws tau ws tau_and_sym ws tau ws close_parenthesis.
tau_or                 => open_parenthesis ws tau ws tau_or_sym ws tau ws close_parenthesis.
tau_neg                => tau_neg_sym ws tau.
# TODO (HIGH) simply consider wff without { and }
# we introduce '{' and '}' to avoid confusion with wff negation
# see the next TODO for an alternative
tau_wff                => open_brace ws wff ws close_brace.

# tau_op_sym
tau_and_sym            => "&&&".
tau_or_sym             => "|||".
# TODO (HIGH) replace by - or other symbol to avoid confusion with wff negation
tau_neg_sym            => "!!!".

# wff
wff_rule               => wff_matcher ws wff_def ws wff_body ws dot ws.
wff_matcher            => wff.
wff_body               => wff | bf_eq_cb | bf_neq_cb | wff_has_clashing_subformulas_cb
			| wff_has_subformula_cb | wff_remove_existential_cb
			| wff_remove_bexistential_cb | wff_remove_buniversal_cb.
wff_rec_relation       => (wff & ~wff_and & ~wff_neg & ~wff_xor & ~wff_conditional
            & ~wff_or & ~wff_all & ~wff_ex & ~wff_imply & ~wff_equiv
            & ~wff_t & ~wff_f & ~capture & ~bool_variable & ~wff_ball & ~wff_bex
            & ~bf_eq & ~ bf_neq & ~bf_less & ~bf_less_equal & ~bf_greater)
            ws wff_def ws wff ws dot ws.

wff                    => wff_ref | wff_and | wff_neg | wff_xor | wff_conditional
			| wff_or | wff_all | wff_ex | wff_imply | wff_equiv
			| wff_t | wff_f | capture | bool_variable | wff_ball | wff_bex
			| bf_eq | bf_neq | bf_less | bf_less_equal | bf_greater.
wff_ref                => sym ws offsets ws wff_ref_args.
wff_ref_args           => open_parenthesis (ws (variable | capture))* ws close_parenthesis.
wff_and                => open_parenthesis ws wff ws wff_and_sym ws wff ws close_parenthesis.
wff_or                 => open_parenthesis ws wff ws wff_or_sym ws wff ws close_parenthesis.
wff_xor                => open_parenthesis ws wff ws wff_xor_sym ws wff ws close_parenthesis.
wff_conditional        => open_parenthesis ws wff ws wff_conditional_sym ws wff ws colon ws wff ws close_parenthesis.
wff_neg                => wff_neg_sym ws wff.
wff_imply              => open_parenthesis ws wff ws wff_imply_sym ws wff ws close_parenthesis.
wff_equiv              => open_parenthesis ws wff ws wff_equiv_sym ws wff ws close_parenthesis.
wff_all                => wff_all_sym ws_required (variable | capture) ws_required wff.
wff_ex                 => wff_ex_sym ws_required (variable | capture) ws_required wff.
wff_ball               => wff_ball_sym ws_required (bool_variable | capture) ws_required wff.
wff_bex                => wff_bex_sym ws_required (bool_variable | capture) ws_required wff.

# relational operators
#
# they are named bf_* as they involve boolean functions,
# but they are not boolean functions themselves, they return a T/F wff value
# and hence, should be considered as wffs
bf_eq                  => open_parenthesis ws bf ws bf_equality_sym ws bf ws close_parenthesis.
bf_neq                 => open_parenthesis ws bf ws bf_nequality_sym ws bf ws close_parenthesis.
bf_less                => open_parenthesis ws bf ws bf_less_sym ws bf ws close_parenthesis.
bf_less_equal          => open_parenthesis ws bf ws bf_less_equal_sym ws bf ws close_parenthesis.
bf_greater             => open_parenthesis ws bf ws bf_greater_sym ws bf ws close_parenthesis.

# wff_op_sym
wff_and_sym            => "&&".
wff_or_sym             => "||".
wff_xor_sym            => '^'.
wff_conditional_sym    => '?'.
wff_neg_sym            => '!'.
wff_imply_sym          => "->".
wff_equiv_sym          => "<->".
wff_all_sym            => "all".
wff_ex_sym             => "ex".
wff_ball_sym           => "ball".
wff_bex_sym            => "bex".
wff_t                  => 'T'.
wff_f                  => 'F'.

# bf
bf_rule                => bf_matcher ws bf_def ws bf_body ws dot ws.
bf_matcher             => bf.
bf_body                => bf | bf_is_zero_cb | bf_is_one_cb | bf_has_clashing_subformulas_cb
			| bf_has_subformula_cb | bf_remove_funiversal_cb | bf_remove_fexistential_cb
			| bf_and_cb | bf_or_cb | bf_xor_cb | bf_neg_cb.
bf                     => bf_ref | bf_constant | bf_and | bf_neg | bf_xor | bf_or
			| bf_all | bf_ex | bf_t | bf_f | variable | capture.
bf_rec_relation        => (bf & ~bf_and & ~bf_neg & ~bf_xor & ~bf_or & ~bf_all & ~bf_ex
            & ~bf_t & ~bf_f & ~capture & ~bf_constant & ~bf_eq & ~bf_neq & ~variable)
            ws bf_def ws bf ws dot ws.
bf_ref                 => sym offsets bf_ref_args.
bf_ref_args            => open_parenthesis (ws (variable | capture))* ws close_parenthesis.
bf_and                 => open_parenthesis ws bf ws bf_and_sym ws bf ws close_parenthesis.
bf_or                  => open_parenthesis ws bf ws bf_or_sym ws bf ws close_parenthesis.
bf_xor                 => open_parenthesis ws bf ws bf_xor_sym ws bf ws close_parenthesis.
bf_neg                 => bf_neg_sym ws bf.
bf_all                 => bf_all_sym ws_required (variable | capture) ws_required bf.
bf_ex                  => bf_ex_sym ws_required (variable | capture) ws_required bf.

# bf_op_sym
bf_and_sym             => '&'.
bf_or_sym              => '|'.
bf_xor_sym             => '+'.
bf_neg_sym             => '~'.
bf_equality_sym        => "=".
bf_nequality_sym       => "!=".
bf_less_sym            => '<'.
bf_less_equal_sym      => "<=".
bf_greater_sym         => '>'.
bf_all_sym             => "fall".
bf_ex_sym              => "fex".
bf_t                   => '1'.
bf_f                   => '0'.

# constant
bf_constant            => open_brace ws constant ws close_brace.

#constants
constant               => binding | capture.
binding                => source_binding | named_binding.
named_binding          => chars.
source_binding         => type ws colon ws source.
type                   => chars | null.

# source related bf_def
source0                => alnum | space | punct.
source                 => (source0)+.

# callbacks

# callbacks must be used in the following cases:
#
# 1.- underlying boolean algebras operations: and, or, xor, neg, less,
# less_equal, greater, subs, eq, neq, is_zero, is_one,... In this case, no
# other way we have to call the uderlying operations of the boolean algebra
# 2.- speed up computations: has_clashing_subformulas, has_subformula,
# remove_existential... In this case, we could use the the callback to
# avoid the creation of intermediate formulas. For instance, if we want
# to check if a formula has a subformula, we could use the callback to
# avoid the creation of the subformulas to check that point.
# 3.- to create new subformulas in other rules, for instance, to create a
# new formula that is the substitution of a variable by a constant.

# TODO (HIGH) earley parser doesn't support tabs in comments
#
# This should be move to a TODO in the parsers...

bf_and_cb              => bf_and_cb_sym ws_required bf_cb_arg ws_required bf_cb_arg.
bf_or_cb               => bf_or_cb_sym ws_required bf_cb_arg ws_required bf_cb_arg.
bf_xor_cb              => bf_xor_cb_sym ws_required bf_cb_arg ws_required bf_cb_arg.
bf_neg_cb              => bf_neg_cb_sym ws_required bf_cb_arg.
bf_eq_cb               => bf_eq_cb_sym ws bf_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg.
bf_neq_cb              => bf_neq_cb_sym ws bf_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg.
bf_is_zero_cb          => bf_is_zero_cb_sym ws bf_cb_arg ws_required bf_cb_arg.
bf_is_one_cb           => bf_is_one_cb_sym ws bf_cb_arg ws_required bf_cb_arg.

bf_remove_funiversal_cb     => bf_remove_funiversal_cb_sym ws bf_cb_arg ws_required bf_cb_arg ws_required bf_cb_arg ws_required bf_cb_arg.
bf_remove_fexistential_cb   => bf_remove_fexistential_cb_sym ws bf_cb_arg ws_required bf_cb_arg ws_required bf_cb_arg ws_required bf_cb_arg.
wff_remove_existential_cb   => wff_remove_existential_cb_sym ws wff_cb_arg ws_required wff_cb_arg.
wff_remove_bexistential_cb  => wff_remove_bexistential_cb_sym ws wff_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg.
wff_remove_buniversal_cb    => wff_remove_buniversal_cb_sym ws wff_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg.

# extra callbacks to speed up computations
bf_has_clashing_subformulas_cb  => bf_has_clashing_subformulas_cb_sym ws bf_cb_arg ws_required bf_cb_arg.
wff_has_clashing_subformulas_cb => wff_has_clashing_subformulas_cb_sym ws wff_cb_arg ws_required wff_cb_arg.
bf_has_subformula_cb            => bf_has_subformula_cb_sym ws bf_cb_arg ws_required bf_cb_arg ws_required bf_cb_arg.
wff_has_subformula_cb           => wff_has_subformula_cb_sym ws wff_cb_arg ws_required wff_cb_arg ws_required wff_cb_arg.

# callback symbols
bf_has_clashing_subformulas_cb_sym  => "bf_has_clashing_subformulas_cb".
bf_has_subformula_cb_sym            => "bf_has_subformula_cb".
wff_has_clashing_subformulas_cb_sym => "wff_has_clashing_subformulas_cb".
wff_has_subformula_cb_sym           => "wff_has_subformula_cb".
wff_remove_existential_cb_sym       => "wff_remove_existential_cb".
wff_remove_bexistential_cb_sym      => "wff_remove_bexistential_cb".
wff_remove_buniversal_cb_sym        => "wff_remove_buniversal_cb".
bf_remove_fexistential_cb_sym       => "bf_remove_fexistential_cb".
bf_remove_funiversal_cb_sym         => "bf_remove_funiversal_cb".

# bultin_args, type is neede to capture appropriate typed arguments, do not try to simplify this
bf_cb_arg              => bf.
wff_cb_arg             => wff.

# bf_cb_syms
bf_and_cb_sym          => "bf_and_cb".
bf_or_cb_sym           => "bf_or_cb".
bf_xor_cb_sym          => "bf_xor_cb".
bf_neg_cb_sym          => "bf_neg_cb".
bf_eq_cb_sym           => "bf_eq_cb".
bf_neq_cb_sym          => "bf_neq_cb".
bf_is_zero_cb_sym      => "bf_is_zero_cb".
bf_is_one_cb_sym       => "bf_is_one_cb".

# cb for tau
tau_collapse_positives_cb      => (tau_collapse_positives_cb_sym ws_required tau_cb_arg ws_required tau_cb_arg ws_required tau_cb_arg)
				| (tau_collapse_positives_cb_sym ws_required tau_cb_arg ws_required tau_cb_arg).
tau_positives_upwards_cb       => tau_positives_upwards_cb_sym ws_required tau_cb_arg ws_required tau_cb_arg.
tau_cb_arg                     => capture | tau.
tau_collapse_positives_cb_sym  => "tau_collapse_positives_cb".
tau_positives_upwards_cb_sym   => "tau_positives_upwards_cb".

# input definition
inputs                 => ws less ws input (ws input)* ws dot ws.
input                  => in ws colon ws open_brace ws source_binding ws close_brace.
# each builder is define on its own string
# TODO explit builders by type: bf, wff, and tau
builder                => ws builder_head ws builder_body ws dot ws.
builder_head           => open_parenthesis ws capture (ws_required capture)* ws close_parenthesis.
builder_body           => bf_builder_body | wff_builder_body | tau_builder_body.
bf_builder_body        => bf_def ws bf.
wff_builder_body       => wff_def ws wff.
tau_builder_body       => tau_def ws tau.
# main posibilities
library                => rules.
rules                  => (ws rule)*.
rule                   => wff_rule | bf_rule | tau_rule.
nso_rr                 => nso_rec_relations nso_main.
nso_rec_relations      => (ws nso_rec_relation)*.
nso_rec_relation       => bf_rec_relation | wff_rec_relation.
nso_main               => ws wff ws dot ws.
gssotc_rr              => gssotc_rec_relations gssotc_main.
gssotc_rec_relations   => (ws gssotc_rec_relation)*.
gssotc_rec_relation    => tau_rec_relation | wff_rec_relation | bf_rec_relation.
gssotc_main            => ws tau ws semicolon.
start                  => (inputs | builder | library | nso_rr | gssotc_rr) ws.
