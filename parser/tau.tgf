# LICENSE
# This software is free for use and redistribution while including this
# license notice, unless:
# 1. is used for commercial or non-personal purposes, or
# 2. used for a product which includes or associated with a blockchain or other
# decentralized database technology, or
# 3. used for a product which includes or associated with the issuance or use
# of cryptographic or electronic currencies/coins/tokens.
# On all of the mentiTd cases, an explicit and written permission is required
# from the Author (Ohad Asor).
# Contact ohad@idni.org for requesting a permission. This license may be
# modified over time by the Author.

@use char class eof, space, digit, xdigit, alpha, alnum, punct, printable.

@trim _, __.

@inline bf > bf_parenthesis > bf,
	wff > wff_parenthesis > wff,
	tau > tau_parenthesis > tau.

#
# as a rule of thumb, to ease navigation of the corresponding tree, the
# non-terminals shouldn't appear in * or + expressions. Otherwise,
# intermediate non terminals would be created and break the expected tree
# structure
#

# TODO (HIGH) remove '(' and ')' from grammar, operator precedence is in this order: ' * | +.
# TODO (HIGH) remove '{' and '}' from grammar, wff negation is in this form: '!' wff.
# TODO (LOW) allow comments in the programs, formulas, ...
# whitespace and comments
comment                => '#' (printable | '\t')* ('\n' | '\r' | eof).
__                     => (space | comment) _.   # whitespace
_                      => [ __ ].                # optional whitespace

# common symbols
dot                    => '.'.
open_parenthesis       => '('.
close_parenthesis      => ')'.
open_bracket           => '['.
close_bracket          => ']'.
open_brace             => '{'.
close_brace            => '}'.
minus                  => '-'.
colon                  => ':'.
semicolon              => ';'.
less                   => '<'.
comma                  => ','.
apostrophe             => "'".
quote                  => '"'.

# tau symbols
tau_def                => ":::=". # for tau rules
tau_builder_def        => "=:::".

# tau_op_sym
tau_and_sym            => "&&&".
tau_or_sym             => "|||".
# TODO (HIGH) replace by - or other symbol to avoid confusion with wff negation
tau_neg_sym            => "!!!".


# wff symbols
wff_def                => "::=". # for wff rec. relations bf_def and rules
wff_builder_def        => "=::".

# wff_op_sym
wff_and_sym            => "&&".
wff_or_sym             => "||".
wff_xor_sym            => '^'.
wff_conditional_sym    => '?'.
wff_neg_sym            => '!'.
wff_imply_sym          => "->".
wff_equiv_sym          => "<->".
wff_all_sym            => "all".
wff_ex_sym             => "ex".
wff_ball_sym           => "bool_all".
wff_bex_sym            => "bool_ex".
wff_t                  => 'T'.
wff_f                  => 'F'.

# bf symbols
bf_def                 => ":=". # for rewriting rules and bf rec. relations bf_def and rules
bf_builder_def         => "=:".

# bf_op_sym
bf_and_sym             => '&'.
bf_or_sym              => '|'.
bf_xor_sym             => '+'.
bf_neg_sym             => apostrophe.
bf_equality_sym        => "=".
bf_nequality_sym       => "!=".
bf_less_sym            => '<'.
bf_less_equal_sym      => "<=".
bf_not_less_equal_sym  => "!<=".
bf_greater_sym         => '>'.
bf_all_sym             => "fall".
bf_ex_sym              => "fex".
bf_splitter_sym        => "S".
bf_t                   => '1'.
bf_f                   => '0'.

# common elements
chars                  => alpha (alnum)*.
digits                 => digit+.
sym                    => chars.

# offsets
offsets                => open_bracket _ offset (_ comma _ offset)* _ close_bracket.
offset                 => num | capture | shift | (variable & ~io_var).
shift                  => (capture | (variable & ~io_var)) _ minus _ num.
num                    => digits.

# IDEA maybe use quantified_variable => (variable | capture) in quantifiers
# to cimplify the code.
variable               => charvar | io_var.
io_var                 => in | out.
in                     => in_var_name open_bracket offset close_bracket.
out                    => out_var_name open_bracket offset close_bracket.
bool_variable          => '?' charvar. #chars & ~wff_t & ~wff_f.
charvar                => (alpha & ~'T' & ~'F') (digit)*.

capture                => capture_var.
capture_var            => '$' chars.
var                    => chars.
in_var_name            => "i_" chars.
out_var_name           => "o_" chars.

# tau
tau_rule               => tau_matcher _ tau_def _ tau_body _ dot.
tau_matcher            => tau.
tau_body               => tau | tau_collapse_positives_cb | tau_positives_upwards_cb.
tau_rec_relation       => tau_ref _ tau_def _ tau _ dot.
tau_ref                => sym _ [offsets] _ tau_ref_args.
# TODO (MEDIUM) properly deal with _ and __ to separate the arguments
tau_ref_args           => open_parenthesis (_ tau_ref_arg)* _ close_parenthesis.
tau_ref_arg            => bf.
tau_ref_arg            => capture | variable.

tau                    => tau_ref.
tau                    => tau_or.
tau                    => tau_and.
tau                    => tau_neg.
tau                    => tau_wff.
tau                    => capture.
tau                    => tau_parenthesis.

tau_parenthesis        => open_parenthesis _ tau _ close_parenthesis.
# TODO (HIGH) check if we could ommit the conjunction in temporal tau formulas
tau_and                => tau _ tau_and_sym _ tau.
tau_or                 => tau _ tau_or_sym  _ tau.
tau_neg                => tau_neg_sym _ tau.
# TODO (HIGH) simply consider wff without { and }.  we introduce '{' and '}' to avoid
# confusion with wff negation
# see the next TODO for an alternative
tau_wff                => open_brace _ wff _ close_brace.

# wff
wff_rule               => wff_matcher _ wff_def _ wff_body _ dot.
wff_matcher            => wff.
wff_body               => bf_eq_cb | bf_neq_cb.
wff_body               => wff_has_clashing_subformulas_cb
                        | wff_has_subformula_cb | wff_remove_existential_cb
                        | wff_remove_bexistential_cb | wff_remove_buniversal_cb.
wff_body               => wff.
wff_rec_relation       => wff_ref _ wff_def _ wff _ dot.

wff                    => wff_ref.
wff                    => wff_conditional.
wff                    => wff_ball.
wff                    => wff_bex.
wff                    => wff_all.
wff                    => wff_ex.
wff                    => wff_imply.
wff                    => wff_equiv.
wff                    => wff_or.
wff                    => wff_and.
wff                    => wff_xor.
wff                    => wff_neg.
wff                    => wff_t | wff_f.
wff                    => bf_interval.
wff                    => bf_neq | bf_eq | bf_nleq_lower| bf_nleq_upper | bf_greater
                        | bf_less_equal | bf_less.
wff                    => capture.
wff                    => bool_variable.
wff                    => wff_parenthesis.

wff_parenthesis        => open_parenthesis _ wff _ close_parenthesis.
wff_ref                => sym _ [offsets] _ wff_ref_args.
# TODO (MEDIUM) properly deal with _ and __ to separate the arguments
wff_ref_args           => open_parenthesis (_ wff_ref_arg)* _ close_parenthesis.
wff_ref_arg            => bf.
wff_ref_arg            => capture | variable.
wff_and                => wff _ [ wff_and_sym _ ] wff.
wff_or                 => wff _ wff_or_sym  _ wff.
wff_xor                => wff _ wff_xor_sym _ wff.
wff_conditional        => wff _ wff_conditional_sym _ wff _ colon _ wff.
wff_neg                => wff_neg_sym _ wff.
wff_imply              => wff _ wff_imply_sym _ wff.
wff_equiv              => wff _ wff_equiv_sym _ wff.
wff_all                => wff_all_sym  __ (variable | capture)      __ wff.
wff_ex                 => wff_ex_sym   __ (variable | capture)      __ wff.
wff_ball               => wff_ball_sym __ (bool_variable | capture) __ wff.
wff_bex                => wff_bex_sym  __ (bool_variable | capture) __ wff.

# relational operators
#
# they are named bf_* as they involve boolean functions,
# but they are not boolean functions themselves, they return a T/F wff value
# and hence, should be considered as wffs
bf_eq                  => bf _ bf_equality_sym       _ bf.
bf_neq                 => bf _ bf_nequality_sym      _ bf.
bf_less                => bf _ bf_less_sym           _ bf.
bf_less_equal          => bf _ bf_less_equal_sym     _ bf.
bf_nleq_lower          => bf _ bf_not_less_equal_sym _ (variable | capture) .
bf_nleq_upper          => (variable | capture)       _ bf_not_less_equal_sym _ bf.
bf_greater             => bf _ bf_greater_sym        _ bf.
bf_interval            => bf _ bf_less_equal_sym     _ (variable | capture) _ bf_less_equal_sym _ bf.

# bf
bf_rule                => bf_matcher _ bf_def _ bf_body _ dot.
bf_matcher             => bf.
bf_body                => bf | bf_is_zero_cb | bf_is_one_cb
                        | bf_has_subformula_cb | bf_remove_funiversal_cb | bf_remove_fexistential_cb
                        | bf_and_cb | bf_or_cb | bf_xor_cb | bf_neg_cb | bf_nleq_lower | bf_nleq_upper.

bf                     => bf_splitter.
bf                     => bf_ref.
bf                     => bf_all.
bf                     => bf_ex.
bf                     => bf_or.
bf                     => bf_and.
bf                     => bf_xor.
bf                     => bf_neg.
bf                     => bf_constant.
bf                     => bf_t | bf_f.
bf                     => capture.
bf                     => variable.
bf                     => bf_parenthesis.

bf_parenthesis         => open_parenthesis _ bf _ close_parenthesis.
bf_rec_relation        => bf_ref _ bf_def _ bf _ dot.
bf_ref                 => sym [offsets] bf_ref_args.
# TODO (MEDIUM) properly deal with _ and __ to separate the arguments
bf_ref_args            => open_parenthesis (_ bf_ref_arg)* _ close_parenthesis.
bf_ref_arg             => bf.
bf_ref_arg             => capture | variable.
bf_and                 => bf _ [ bf_and_sym _ ] bf.
bf_or                  => bf _ bf_or_sym  _ bf.
bf_xor                 => bf _ bf_xor_sym _ bf.
bf_neg                 => bf _ bf_neg_sym.
bf_all                 => bf_all_sym __ (variable | capture) __ bf.
bf_ex                  => bf_ex_sym  __ (variable | capture) __ bf.
bf_splitter            => bf_splitter_sym _ open_parenthesis _ bf _ close_parenthesis.

# constant
bf_constant            => open_brace _ constant _ close_brace.

#constants
constant               => binding | capture.
binding                => source_binding | named_binding.
named_binding          => chars.
source_binding         => type _ colon _ source.
type                   => chars | null.

# source related bf_def
source0                => alnum | space | punct.
source                 => (source0)+.

# callbacks

# callbacks must be used in the following cases:
#
# 1.- underlying boolean algebras operations: and, or, xor, neg, less,
# less_equal, greater, subs, eq, neq, is_zero, is_one,... In this case, no
# other way we have to call the uderlying operations of the boolean algebra
# 2.- speed up computations: has_clashing_subformulas, has_subformula,
# remove_existential... In this case, we could use the the callback to
# avoid the creation of intermediate formulas. For instance, if we want
# to check if a formula has a subformula, we could use the callback to
# avoid the creation of the subformulas to check that point.
# 3.- to create new subformulas in other rules, for instance, to create a
# new formula that is the substitution of a variable by a constant.

# TODO (HIGH) earley parser doesn't support tabs in comments
#
# This should be move to a TODO in the parsers...

bf_and_cb              => bf_and_cb_sym     __ bf_cb_arg __ bf_cb_arg.
bf_or_cb               => bf_or_cb_sym      __ bf_cb_arg __ bf_cb_arg.
bf_xor_cb              => bf_xor_cb_sym     __ bf_cb_arg __ bf_cb_arg.
bf_neg_cb              => bf_neg_cb_sym     __ bf_cb_arg.
bf_eq_cb               => bf_eq_cb_sym      __ bf_cb_arg __ wff_cb_arg __ wff_cb_arg.
bf_neq_cb              => bf_neq_cb_sym     __ bf_cb_arg __ wff_cb_arg __ wff_cb_arg.
bf_is_zero_cb          => bf_is_zero_cb_sym __ bf_cb_arg __ bf_cb_arg.
bf_is_one_cb           => bf_is_one_cb_sym  __ bf_cb_arg __ bf_cb_arg.

bf_remove_funiversal_cb     => bf_remove_funiversal_cb_sym    __ bf_cb_arg  __ bf_cb_arg  __ bf_cb_arg  __ bf_cb_arg.
bf_remove_fexistential_cb   => bf_remove_fexistential_cb_sym  __ bf_cb_arg  __ bf_cb_arg  __ bf_cb_arg  __ bf_cb_arg.
wff_remove_existential_cb   => wff_remove_existential_cb_sym  __ wff_cb_arg __ wff_cb_arg.
wff_remove_bexistential_cb  => wff_remove_bexistential_cb_sym __ wff_cb_arg __ wff_cb_arg __ wff_cb_arg __ wff_cb_arg.
wff_remove_buniversal_cb    => wff_remove_buniversal_cb_sym   __ wff_cb_arg __ wff_cb_arg __ wff_cb_arg __ wff_cb_arg.

# extra callbacks to speed up computations
wff_has_clashing_subformulas_cb => wff_has_clashing_subformulas_cb_sym __ wff_cb_arg __ wff_cb_arg.
bf_has_subformula_cb            => bf_has_subformula_cb_sym            __ bf_cb_arg  __ bf_cb_arg  __ bf_cb_arg.
wff_has_subformula_cb           => wff_has_subformula_cb_sym           __ wff_cb_arg __ wff_cb_arg __ wff_cb_arg.

# callback symbols
bf_has_subformula_cb_sym            => "bf_has_subformula_cb".
wff_has_clashing_subformulas_cb_sym => "wff_has_clashing_subformulas_cb".
wff_has_subformula_cb_sym           => "wff_has_subformula_cb".
wff_remove_existential_cb_sym       => "wff_remove_existential_cb".
wff_remove_bexistential_cb_sym      => "wff_remove_bexistential_cb".
wff_remove_buniversal_cb_sym        => "wff_remove_buniversal_cb".
bf_remove_fexistential_cb_sym       => "bf_remove_fexistential_cb".
bf_remove_funiversal_cb_sym         => "bf_remove_funiversal_cb".

# bultin_args, type is neede to capture appropriate typed arguments, do not try to simplify this
bf_cb_arg              => bf.
wff_cb_arg             => wff.

# bf_cb_syms
bf_and_cb_sym          => "bf_and_cb".
bf_or_cb_sym           => "bf_or_cb".
bf_xor_cb_sym          => "bf_xor_cb".
bf_neg_cb_sym          => "bf_neg_cb".
bf_eq_cb_sym           => "bf_eq_cb".
bf_neq_cb_sym          => "bf_neq_cb".
bf_is_zero_cb_sym      => "bf_is_zero_cb".
bf_is_one_cb_sym       => "bf_is_one_cb".

# cb for tau
tau_collapse_positives_cb      => (tau_collapse_positives_cb_sym __ tau_cb_arg __ tau_cb_arg __ tau_cb_arg)
                                | (tau_collapse_positives_cb_sym __ tau_cb_arg __ tau_cb_arg).
tau_positives_upwards_cb       => tau_positives_upwards_cb_sym __ tau_cb_arg __ tau_cb_arg.
tau_cb_arg                     => capture | tau.
tau_collapse_positives_cb_sym  => "tau_collapse_positives_cb".
tau_positives_upwards_cb_sym   => "tau_positives_upwards_cb".

# input definition
inputs                 => _ less _ input (_ input)* _ dot.
input                  => in _ colon _ open_brace _ source_binding _ close_brace.
# each builder is define on its own string
builder                => _ builder_head _ builder_body _ dot.
builder_head           => open_parenthesis _ capture (__ capture)* _ close_parenthesis.
builder_body           => bf_builder_body | wff_builder_body | tau_builder_body.
bf_builder_body        => bf_builder_def _ bf.
wff_builder_body       => wff_builder_def _ wff.
tau_builder_body       => tau_builder_def _ tau.
# main posibilities
library                => rules.
rules                  => (_ rule)*.
rule                   => wff_rule | bf_rule | tau_rule.
nso_rr                 => nso_rec_relations nso_main.
nso_rec_relations      => (_ nso_rec_relation)*.
nso_rec_relation       => bf_rec_relation | wff_rec_relation.
nso_main               => _ wff _ dot.
gssotc_rr              => gssotc_rec_relations gssotc_main.
gssotc_rec_relations   => (_ gssotc_rec_relation)*.
gssotc_rec_relation    => tau_rec_relation | wff_rec_relation | bf_rec_relation.
gssotc_main            => _ tau _ semicolon.
start                  => (inputs | builder | library | nso_rr | gssotc_rr) _.

# cli related rules, using cli as starting point for parsing

# TODO do the same with the other starting points: library, inputs, builder, nso_rr, nso, gssotc, gssotc_rr...
# depending on the use case of the grammar.
cli                    => _ cli_command (_ dot _ cli_command)*.
cli_command            => help_cmd | version_cmd | quit_cmd | clear_cmd.
cli_command            => get_cmd | set_cmd | toggle_cmd.
cli_command            => list_outputs_cmd | clear_outputs_cmd | print_output_cmd.
cli_command            => file.
cli_command            => normalize_cmd | execute_cmd | solve_cmd
                        | is_satisfiable_cmd | is_valid_cmd | is_unsatisfiable_cmd
                        | bf_dnf_cmd | bf_cnf_cmd | bf_anf_cmd
                        | bf_nnf_cmd | bf_pnf_cmd | bf_mnf_cmd
                        | wff_onf_cmd | wff_dnf_cmd | wff_cnf_cmd
                        | wff_anf_cmd | wff_nnf_cmd | wff_pnf_cmd | wff_mnf_cmd
                        | bf_substitute_cmd | wff_substitute_cmd
                        | bf_instantiate_cmd | wff_instantiate_cmd
                        | def_rule_cmd | def_list_cmd | def_del_cmd | def_clear_cmd.
cli_command            => bf.
cli_command            => wff.
cli_command            => nso_rr.

normalize_cmd          => normalize_cmd_sym __ normalize_cmd_arg.
normalize_cmd_arg      => wff.
normalize_cmd_arg      => nso_rr.
normalize_cmd_arg      => output | wff_selection.

solve_cmd              => solve_cmd_sym __ solve_cmd_arg.
solve_cmd_arg          => wff.
solve_cmd_arg          => output | wff_selection.

execute_cmd            => execute_cmd_sym __ execute_cmd_arg.
execute_cmd_arg        => tau.
execute_cmd_arg        => gssotc_rr.

is_satisfiable_cmd     => is_satisfiable_cmd_sym __ is_satisfiable_cmd_arg.
is_satisfiable_cmd_arg => gssotc_rr.

is_valid_cmd           => is_valid_cmd_sym __ is_valid_cmd_arg.
is_valid_cmd_arg       => gssotc_rr.

is_unsatisfiable_cmd     => is_unsatisfiable_cmd_sym __ is_unsatisfiable_cmd_arg.
is_unsatisfiable_cmd_arg => gssotc_rr.

file                   => file_sym quote file_path quote.

bf_instantiate_cmd      => instantiate_cmd_sym __
                          # variable to be instantiated
                          variable __
                          # wff to be used for instantiation
                          (bf | bf_selection | output) __
                          # nso_rr or output or selection where to instantiate
                          (bf_selection | output).
wff_instantiate_cmd     => instantiate_cmd_sym __
                          # variable to be instantiated
                          variable __
                          # wff to be used for instantiation
                          (wff | wff_selection | output) __
                          # nso_rr or output or selection where to instantiate
                          (wff_selection | output).
bf_substitute_cmd      => substitute_cmd_sym __
                          # bf or output or selection to be used for substitution
                          (bf | output | bf_selection) __
                          # bf or output or selection where to substitute
                          (output | bf_selection | bf_selection)
                          # nso_rr or output or selection where to substitute
                          (bf_selection | output).
wff_substitute_cmd     => substitutecmd__sym __
                          # wff or output or selection to be used for substitution
                          (wff | output | wff_selection) __
                          # wff or output or selection where to substitute
                          (output | wff_selection)
                          # nso_rr or output or selection where to substitute
                          (wff_selection | output).
bf_dnf_cmd             => dnf_cmd_sym __ (bf | output | bf_selection).
bf_cnf_cmd             => cnf_cmd_sym __ (bf | output | bf_selection).
bf_anf_cmd             => anf_cmd_sym __ (bf | output | bf_selection).
bf_nnf_cmd             => nnf_cmd_sym __ (bf | output | bf_selection).
bf_pnf_cmd             => pnf_cmd_sym __ (bf | output | bf_selection).
bf_mnf_cmd             => mnf_cmd_sym __ (bf | output | bf_selection).
wff_onf_cmd            => onf_cmd_sym __ variable __ (wff | output | wff_selection).
wff_dnf_cmd            => dnf_cmd_sym __ (wff | output | wff_selection).
wff_cnf_cmd            => cnf_cmd_sym __ (wff | output | wff_selection).
wff_anf_cmd            => anf_cmd_sym __ (wff | output | wff_selection).
wff_nnf_cmd            => nnf_cmd_sym __ (wff | output | wff_selection).
wff_pnf_cmd            => pnf_cmd_sym __ (wff | output | wff_selection).
wff_mnf_cmd            => mnf_cmd_sym __ (wff | output | wff_selection).

def_rule_cmd           => def_cmd_sym __ def_rule_cmd_arg.
def_rule_cmd_arg       => (bf_rec_relation | wff_rec_relation | tau_rec_relation).
def_list_cmd           => def_cmd_sym __ def_cmd_list.
def_del_cmd            => def_cmd_sym __ def_cmd_del __ digits.
def_clear_cmd          => def_cmd_sym __ def_cmf_clear.

help_cmd               => help_cmd_sym [ __ cli_cmd_sym ].
version_cmd            => version_cmd_sym.
quit_cmd               => quit_cmd_sym.
clear_cmd              => clear_cmd_sym.

# TODO (HIGH) selection should take outputs as arguments
wff_selection          => selection_sym __ digits.
bf_selection           => selection_sym __ digits.
bf_var_selection       => selection_sym __ digits.
wff_var_selection      => selection_sym __ digits.

# TODO (HIGH) add support for file paths
file_path              => chars.
output                 => absolute_output | relative_output.
absolute_output        => (absolute_output_sym | output_sym __) output_id.
relative_output        => relative_output_sym output_id.
output_id              => digits.

list_outputs_cmd       => output_sym | absolute_output_sym | relative_output_sym.
clear_outputs_cmd      => (output_sym __ | absolute_output_sym | relative_output_sym) clear_sym.
print_output_cmd       => output.

cli_cmd_sym            => help_cmd_sym | version_cmd_sym | quit_cmd_sym
                        | clear_cmd_sym
			| output_sym | absolute_output_sym | relative_output_sym
                        | selection_sym | instantiate_cmd_sym | substitute_cmd_sym
                        | def_cmd_sym
                        | normalize_cmd_sym | execute_cmd_sym | file_cmd_sym
                        | solve_cmd_sym | is_satisfiable_cmd_sym | is_valid_cmd_sym
                        | is_unsatisfiable_cmd_sym | examples_sym
                        | get_cmd_sym | set_cmd_sym | toggle_cmd_sym
                        | cnf_cmd_sym | dnf_cmd_sym | nnf_cmd_sym | mnf_cmd_sym | onf_cmd_sym.

# cli symbols
help_cmd_sym           => "h" | "help".
version_cmd_sym        => "v" | "version".
quit_cmd_sym           => "q" | "e" | "quit" | "exit".
instantiate_cmd_sym    => "i" | "instantiate".
substitute_cmd_sym     => "s" | "substitute".
file_cmd_sym           => "r" | "read".
clear_cmd_sym          => "c" | "clear".

normalize_cmd_sym      => "n" | "normalize".
# TODO (LOW) also use 'e'... after removing the exit command variant.
execute_cmd_sym        => "execute".
solve_cmd_sym          => "solve".

is_satisfiable_cmd_sym   => "sat".
is_valid_cmd_sym         => "valid".
is_unsatisfiable_cmd_sym => "unsat".

onf_cmd_sym            => "onf".
dnf_cmd_sym            => "dnf".
cnf_cmd_sym            => "cnf".
anf_cmd_sym            => "anf".
nnf_cmd_sym            => "nnf".
pnf_cmd_sym            => "pnf".
mnf_cmd_sym            => "mnf".

def_cmd_sym            => "def".
def_cmd_list           => "list".
def_cmd_del            => "del".
def_cmf_clear          => "clear".

selection_sym          => "s" | "selection".
output_sym             => "o" | "output".
absolute_output_sym    => "&".
relative_output_sym    => "%".

examples_sym            => "examples".
# cofiguration commands
# TODO (HIGH) implement 'set charvar...' to set length of variables to char instead to chars

# get option_sym / set option_sym [ = ] value / toggle option_sym
get_cmd                => get_cmd_sym [ __ option ].
set_cmd                => set_cmd_sym __ option (__ | _ '=' _) option_value.
toggle_cmd             => toggle_cmd_sym __ bool_option.

get_cmd_sym            => "get".
set_cmd_sym            => "set".
toggle_cmd_sym         => "toggle".

# options and their names
option                 => bool_option | severity_opt. # | string_option | integer_option.
bool_option            => status_opt | colors_opt | debug_repl_opt.
status_opt             => "s" | "status".
colors_opt             => "c" | "color" | "colors".
severity_opt           => "sev" | "severity".
debug_repl_opt         => "d" | "dr" | "dbg" | "debug" | "debug-repl".

# option values
option_value           => option_value_true | option_value_false | severity.
option_value_true      => "t" | "true"  | "on"  | "1" | "y" | "yes".
option_value_false     => "f" | "false" | "off" | "0" | "n" | "no".
severity               => error_sym | debug_sym | trace_sym | info_sym.
error_sym              => "e" | "error".
info_sym               => "i" | "info".
debug_sym              => "d" | "debug".
trace_sym              => "t" | "trace".
