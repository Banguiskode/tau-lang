@use_char_class eof, space, digit, xdigit, alpha, alnum, punct, printable.

# in all those cases: x and y is are vars and "tau" is a constant 
# x & tau // wrong
# x & {tau} // ok
# x && {tau} // wrong
# x && tau // wrong
# x &&& tau // wrong
# x &&& {tau} // ok
# x && y // wrong
# x & y // ok if x and y came from the same boolean algebra
# x &&& y // ok if x and y came from the boolean algebra of tau formulas

#
# as a rule of thumb, to ease navigation of the corresponding tree, the 
# non-terminals shouldn't appear in * or + expressions. Otherwise, 
# intermediate non terminals would be created and break the expected tree 
# structure
#

# whitespace and comments
eol				=> '\n' | '\r' | eof.
ws_comment		=> '#' eol | '#' printable+ eol.
ws_required		=> space ws | ws_comment ws.
ws				=> ws_required | null.

# characters
hex_escape			=> "\\x" xdigit xdigit.
unicode_escape		=> "\\u" xdigit xdigit xdigit xdigit.
char_escape_encode	=> hex_escape | unicode_escape.

# defining char/string/qstring as all chars but its wrapping character
# enables using TAB and new lines in char(')/string(")/bqstring(`)
# sequences

# common stuff copy cut from tml grammar
esc				=> "\\\\".
q_char			=> '\''.
q_str			=> '"'.
q_bqstr			=> '`'.
char_punct		=> punct & ~q_char & ~q_str & ~q_bqstr
					& ~(esc q_char) & ~(esc q_str) & ~(esc q_bqstr).

char0			=> alnum | space | char_escape_encode | char_punct.
char_			=> char0 | esc q_char |     q_str |     q_bqstr.
string_char		=> char0 |     q_char | esc q_str |     q_bqstr.
bqstring_char	=> char0 |     q_char |     q_str | esc q_bqstr.
chars			=> alpha (alnum)*.

char_class    	=> "eof" | "alnum" | "alpha" | "blank" | "cntrl" | "digit"
				| "graph" | "lower" | "printable" | "punct" | "space"
				| "upper" | "xdigit".

# elements
sym				=> ws chars ws.

# common symbols
definition			=> ws ":=" ws.
equality			=> ws '=' ws. 
nequality			=> ws "!=" ws. 
dot 				=> ws '.' ws.
open_parenthesis	=> ws '(' ws.
close_parenthesis	=> ws ')' ws.
open_bracket		=> ws '[' ws.
close_bracket		=> ws ']' ws.
open_brace			=> ws '{' ws.
close_brace			=> ws '}' ws.
minus				=> ws '-' ws.
colon				=> ws ':' ws.

# indexes
indexes			=> open_bracket (index)* close_bracket.
index			=> variable | offset.
num				=> digit+.

# variables 
variable		=> var | ignore | capture.

# QUESTION does timed variables have one index or several?
timed			=> ( var_in| var_out) indexes. 
offset			=> variable | variable minus num.
ignore 			=> '_'.
capture			=> ws '$' chars ws.
var				=> ws '?' chars ws .
var_in			=> ws "?i_" chars ws. # instead of '<', easy to remember
var_out			=> ws "?o_" chars ws. # instead of '>', easy to remember

# wff
wff_rule		=> (wff_matcher | wff_ref) definition wff dot.
wff_matcher		=> wff.
wff_ref			=> sym indexes wff_ref_args.
wff_ref_args	=> open_parenthesis (variable)* close_parenthesis.

wff 			=> wff_eq | wff_neq | wff_ref | wff_and | wff_neg | wff_xor 
					| wff_or | wff_all | wff_ex | T | F | variable | timed
					| wff_imply | wff_equiv | wff_coimply.
wff_eq 			=> open_parenthesis bf equality F close_parenthesis.
wff_neq 		=> open_parenthesis bf nequality F close_parenthesis.
wff_and			=> open_parenthesis wff wff_and_sym wff close_parenthesis.
wff_or			=> open_parenthesis wff wff_or_sym wff close_parenthesis.
wff_xor			=> open_parenthesis wff wff_xor_sym wff close_parenthesis.
wff_neg			=> wff_neg_sym wff.
wff_imply		=> open_parenthesis wff wff_imply_sym wff close_parenthesis.
wff_equiv		=> open_parenthesis wff wff_equiv_sym wff close_parenthesis.
wff_coimply		=> open_parenthesis wff wff_coimply_sym wff close_parenthesis.
wff_all			=> wff_all_sym variable wff.
wff_ex			=> wff_ex_sym variable wff.

# wff_op_sym
wff_and_sym		=> ws "wff_and" ws.
wff_or_sym		=> ws "wff_or" ws.
wff_xor_sym		=> ws "wff_xor" ws.
wff_neg_sym		=> ws "wff_neg" ws.
wff_imply_sym	=> ws "wff_imply" ws.
wff_equiv_sym	=> ws "wff_equiv" ws.
wff_coimply_sym	=> ws "wff_coimply" ws.	
wff_all_sym		=> ws "wff_all" ws.
wff_ex_sym		=> ws "wff_ex" ws.

#cbf
cbf_rule 		=> (cbf_matcher | cbf_ref) definition cbf dot.
cbf_matcher		=> cbf.
cbf_ref 		=> sym indexes cbf_ref_args.
cbf_ref_args	=> open_parenthesis (variable)* close_parenthesis.

cbf 				=> bf | cbf_if | cbf_ref | cbf_and | cbf_neg | cbf_xor | cbf_or
						| cbf_imply | cbf_equiv | cbf_coimply | T | F.
cbf_if				=> cbf_if_sym cbf_if_condition 
						cbf_then_sym cbf_if_then 
						cbf_else_sym cbf_if_else. 
cbf_if_condition	=> wff.
cbf_if_then			=> cbf.
cbf_if_else			=> cbf.
cbf_and				=> open_parenthesis cbf cbf_and_sym cbf close_parenthesis.
cbf_or				=> open_parenthesis cbf cbf_or_sym cbf close_parenthesis.
cbf_xor				=> open_parenthesis cbf cbf_xor_sym cbf close_parenthesis.
cbf_neg				=> cbf_neg_sym cbf.
cbf_imply			=> open_parenthesis cbf cbf_imply_sym cbf close_parenthesis.
cbf_equiv			=> open_parenthesis cbf cbf_equiv_sym cbf close_parenthesis.
cbf_coimply			=> open_parenthesis cbf cbf_coimply_sym cbf close_parenthesis.

# cbf_op_sym
cbf_and_sym			=> ws "cbf_and" ws.
cbf_or_sym			=> ws "cbf_or" ws.
cbf_xor_sym			=> ws "cbf_xor" ws.
cbf_neg_sym			=> ws "cbf_neg" ws.
cbf_imply_sym		=> ws "cbf_imply" ws.
cbf_equiv_sym		=> ws "cbf_equiv" ws.
cbf_coimply_sym		=> ws "cbf_coimply" ws.	
cbf_if_sym			=> ws "if" ws.
cbf_then_sym		=> ws "then" ws.
cbf_else_sym		=> ws "else" ws.

# bf - TODO bf => constant | bf & bf | bf | bf | ~bf | bf ^ bf | in[n][t] 
# | out[n][t] <<< this thing is important!!!
#
# QUESTION: Does timed vars appear only in bf formulas?

bf_rule			=> bf_matcher definition bf dot.
bf_matcher		=> bf.
bf				=> bf_constant | bf_and | bf_neg | bf_xor | bf_or
					| bf_imply | bf_equiv | bf_coimply
					| bf_less | bf_less_equal | bf_greater
					| bf_all | bf_ex | variable | timed | bf_subs_cb.
bf_and			=> open_parenthesis bf bf_and_sym bf close_parenthesis.
bf_or			=> open_parenthesis bf bf_or_sym bf close_parenthesis.
bf_xor			=> open_parenthesis bf bf_xor_sym ws bf close_parenthesis.
bf_neg			=> bf_neg_sym bf.
bf_less			=> open_parenthesis bf bf_less_sym bf close_parenthesis.
bf_less_equal	=> open_parenthesis bf bf_less_equal_sym bf close_parenthesis.
bf_greater		=> open_parenthesis bf bf_greater_sym bf close_parenthesis.
bf_imply		=> open_parenthesis bf bf_imply_sym bf close_parenthesis.
bf_equiv		=> open_parenthesis bf bf_equiv_sym bf close_parenthesis.
bf_coimply		=> open_parenthesis bf bf_coimply_sym bf close_parenthesis.
bf_all			=> bf_all_sym variable (bf | capture).
bf_ex			=> bf_ex_sym variable (bf | capture).

# bf_op_sym
bf_and_sym			=> ws "bf_and" ws.
bf_or_sym			=> ws "bf_or" ws.
bf_xor_sym			=> ws "bf_xor" ws.
bf_neg_sym			=> ws "bf_neg" ws.
bf_less_sym			=> ws "bf_less" ws.
bf_less_equal_sym	=> ws "bf_less_equal" ws.
bf_greater_sym		=> ws "bf_greater" ws.
bf_imply_sym		=> ws "bf_imply" ws.
bf_equiv_sym		=> ws "bf_equiv" ws.
bf_coimply_sym		=> ws "bf_coimply" ws.	
bf_all_sym			=> ws "bf_all" ws.
bf_ex_sym			=> ws "bf_ex" ws.

# constant
bf_constant		=> T | F | open_brace constant close_brace.

#constants, test_bf is included for testing purposes only
constant		=> bf_cte_cb | binding | capture | ignore.
T				=> ws 'T' ws.
F				=> ws 'F' ws.
bf_cte_cb		=> bf_and_cb | bf_or_cb | bf_xor_cb | bf_neg_cb 
					| bf_imply_cb | bf_equiv_cb | bf_coimply_cb
					| bf_less_cb | bf_less_equal_cb | bf_greater_cb.
binding			=> source_binding | named_binding.
named_binding	=> chars.
source_binding	=> type colon source.
type 			=> chars | null.

# source related definition
source0			=> alnum | space | char_escape_encode | char_punct.
source			=> (source0)+.

# bf_cbs
bf_and_cb			=> bf_cb_arg bf_and_cb_sym bf_cb_arg.
bf_or_cb			=> bf_cb_arg bf_or_cb_sym bf_cb_arg.
bf_xor_cb			=> bf_cb_arg bf_xor_cb_sym bf_cb_arg.
bf_neg_cb			=> bf_neg_cb_sym bf_cb_arg.
bf_less_cb			=> bf_cb_arg bf_less_cb_sym bf_cb_arg.
bf_less_equal_cb	=> bf_cb_arg bf_less_equal_cb_sym bf_cb_arg.
bf_greater_cb		=> bf_cb_arg bf_greater_cb_sym bf_cb_arg.
bf_imply_cb			=> bf_cb_arg bf_imply_cb_sym bf_cb_arg.
bf_equiv_cb			=> bf_cb_arg bf_equiv_cb_sym bf_cb_arg.
bf_coimply_cb		=> bf_cb_arg bf_coimply_cb_sym bf_cb_arg.
bf_subs_cb			=> bf_subs_cb_sym bf_cb_arg bf_cb_arg bf_cb_arg.

# bf_bultin_arg
bf_cb_arg	=> capture | binding | T | F.

# bf_cb_syms
bf_and_cb_sym			=> ws "bf_and_cb" ws.
bf_or_cb_sym			=> ws "bf_or_cb" ws.
bf_xor_cb_sym			=> ws "bf_xor_cb" ws.
bf_neg_cb_sym			=> ws "bf_neg_cb" ws.
bf_less_cb_sym			=> ws "bf_less_cb" ws.
bf_less_equal_cb_sym	=> ws "bf_less_equal_cb" ws.
bf_greater_cb_sym		=> ws "bf_greater_cb" ws.
bf_imply_cb_sym			=> ws "bf_imply_cb" ws.
bf_equiv_cb_sym			=> ws "bf_equiv_cb" ws.
bf_coimply_cb_sym		=> ws "bf_coimply_cb" ws.
bf_subs_cb_sym			=> ws "bf_subs_cb" ws.

# main - TODO - tau & tau /n tau && tau /n tau &&& tau
main			=> wff dot.
rule			=> wff_rule | cbf_rule | bf_rule.
rules			=> (rule)*.
formula			=> rules main.
library 		=> rules.
start			=> formula | library.

